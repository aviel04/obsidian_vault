/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => GoogleKeepImportPlugin2,
  invalidChars_allOrWindowsPreset: () => invalidChars_allOrWindowsPreset,
  invalidChars_appleOrAndroidPreset: () => invalidChars_appleOrAndroidPreset,
  invalidChars_linuxPreset: () => invalidChars_linuxPreset
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/logic/import-logic.ts
var import_obsidian6 = require("obsidian");

// src/modals/import-progress-modal/import-progress-modal.ts
var import_obsidian = require("obsidian");

// src/components/import-summary/import-summary.ts
var ImportSummary = class {
  constructor(parentEl) {
    this.summaryEl = parentEl.createDiv("gki_import-summary");
  }
  hide() {
    this.summaryEl.addClass("gki_hidden");
  }
  show() {
    this.summaryEl.addClass("gki_smooth-appear");
    this.summaryEl.removeClass("gki_hidden");
  }
  addItem(label) {
    let bubbleEl;
    let pBubbleEl;
    let valueSpan;
    bubbleEl = this.summaryEl.createDiv("gki_import-imported");
    pBubbleEl = bubbleEl.createEl("p");
    valueSpan = pBubbleEl.createEl("span", { cls: "gki_import-number", text: `0` });
    pBubbleEl.createEl("br");
    pBubbleEl.createEl("span", { cls: "gki_import-label", text: label });
    return valueSpan;
  }
};

// src/components/support-button-set/support-button-set.ts
var SupportButtonSet = class {
  constructor(settingEl) {
    settingEl.addButton((btn) => {
      btn.setClass("gki_button");
      btn.setTooltip("Contact @daledesilva@indieweb.social");
      btn.setIcon("mastodon");
      btn.onClick((e) => {
        window.open("https://indieweb.social/@daledesilva", "_blank");
      });
    });
    settingEl.addButton((btn) => {
      btn.setClass("gki_button");
      btn.setTooltip("Contact @daledesilva");
      btn.setIcon("twitter");
      btn.onClick((e) => {
        window.open("https://twitter.com/daledesilva", "_blank");
      });
    });
    settingEl.addButton((btn) => {
      btn.setClass("gki_button");
      btn.setTooltip("Support developer");
      btn.setIcon("heart");
      btn.onClick((e) => {
        window.open("https://ko-fi.com/N4N3JLUCW", "_blank");
      });
    });
  }
};

// src/modals/import-progress-modal/import-progress-modal.ts
var ImportProgressModal = class extends import_obsidian.Modal {
  constructor(plugin, fileImporter) {
    super(plugin.app);
    this.outputStr = "";
    this.importCompleted = false;
    this.fileImporter = fileImporter;
  }
  showModal() {
    return new Promise((resolve, reject) => {
      this.open();
      this.resolveModal = resolve;
      this.rejectModal = reject;
    });
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText("Import in progress");
    this.modalHeaderDiv = contentEl.createDiv();
    const progressBarEl = contentEl.createEl("div", { cls: "gki_progress-bar" });
    this.bar = progressBarEl.createEl("div", { cls: "gki_bar" });
    let importSummary = new ImportSummary(contentEl);
    this.remainingSpan = importSummary.addItem("remaining");
    this.skippedSpan = importSummary.addItem("skipped");
    this.failedSpan = importSummary.addItem("failed");
    this.importedSpan = importSummary.addItem("imported");
    this.outputLogEl = contentEl.createDiv("gki_error-log");
    this.modalActions = new import_obsidian.Setting(this.contentEl);
    new SupportButtonSet(this.modalActions);
    this.updateProgressVisuals();
  }
  updateProgressVisuals() {
    const totalImports = this.fileImporter.getTotalImports();
    const {
      successCount,
      skipCount,
      failCount,
      newLogEntries
    } = this.fileImporter.getLatestProgress();
    const perc = (successCount + skipCount + failCount) / totalImports * 100;
    this.bar.setAttr("style", `width: ${perc}%`);
    this.remainingSpan.setText(`${totalImports - successCount - failCount - skipCount}`);
    this.skippedSpan.setText(`${skipCount}`);
    this.failedSpan.setText(`${failCount}`);
    this.importedSpan.setText(`${successCount}`);
    for (let i = 0; i < newLogEntries.length; i++) {
      this.addOutputLine(newLogEntries[i]);
    }
    if (successCount + skipCount + failCount == totalImports) {
      this.importCompleted = true;
      this.applyCompletedState();
    } else {
      window.requestAnimationFrame(() => this.updateProgressVisuals());
    }
  }
  addOutputLine(options) {
    const itemEl = this.outputLogEl.createDiv({ cls: "gki_item" });
    const itemHeaderEl = itemEl.createEl("p", { cls: "gki_item-header" });
    const statusClass = options.status.toLowerCase();
    itemHeaderEl.createEl("span", { cls: `gki_status ${statusClass}` }).setText(options.status);
    itemHeaderEl.createEl("span", { cls: "gki_title" }).setText(options.title);
    const itemBodyEl = itemEl.createEl("p", { cls: "gki_item-body" });
    itemBodyEl.createEl("p", { cls: "gki_desc" }).innerHTML = options.desc;
    this.outputLogEl.addClass("gki_visible");
  }
  applyCompletedState() {
    this.titleEl.empty();
    this.modalHeaderDiv.createEl("h1", { text: "Import Complete" });
    this.modalActions.addButton((btn) => {
      btn.setCta();
      btn.setClass("gki_button");
      btn.setButtonText("Close");
      btn.onClick((e) => {
        this.close();
      });
    });
  }
  onClose() {
    this.titleEl.empty();
    this.contentEl.empty();
    if (!this.importCompleted) {
      this.rejectModal("Import cancelled");
    }
  }
};

// src/logic/string-processes.ts
var singleOrPlural = (count, singleVersion, pluralVersion) => {
  if (count == 1 || count == -1) {
    return singleVersion;
  } else {
    if (pluralVersion) {
      return pluralVersion;
    } else {
      return `${singleVersion}s`;
    }
  }
};
function filenameSanitize(str, settings) {
  let nameStr = str;
  for (let i = 0; i < settings.problemChars.length; i++) {
    const problemChar = settings.problemChars[i].char;
    const replacement = settings.problemChars[i].replacement;
    nameStr = nameStr.split(problemChar).join(replacement);
  }
  for (let i = 0; i < settings.invalidChars.length; i++) {
    const invalidChar = settings.invalidChars[i].char;
    const replacement = settings.invalidChars[i].replacement;
    nameStr = nameStr.split(invalidChar).join(replacement).trim();
  }
  return nameStr;
}
function folderPathSanitize(str, settings) {
  let pathArr;
  let pathStr = str;
  pathArr = pathStr.split("/");
  for (let j = 0; j < pathArr.length; j++) {
    for (let i = 0; i < settings.problemChars.length; i++) {
      const problemChar = settings.problemChars[i].char;
      const replacement = settings.problemChars[i].replacement;
      pathArr[j] = pathArr[j].split(problemChar).join(replacement).trim();
    }
    for (let i = 0; i < settings.invalidChars.length; i++) {
      const invalidChar = settings.invalidChars[i].char;
      const replacement = settings.invalidChars[i].replacement;
      pathArr[j] = pathArr[j].split(invalidChar).join(replacement).trim();
    }
  }
  pathStr = pathArr.join("/");
  while (pathStr.slice(-1) == "/") {
    pathStr = pathStr.slice(0, -1).trim();
  }
  return pathStr;
}
function getFileExtension(filename) {
  let fileAndExt = filename.split(".");
  if (fileAndExt.length <= 1)
    return "";
  let ext = fileAndExt.pop();
  if (ext) {
    return ext.toLowerCase();
  } else {
    return "";
  }
}
function getNameAndExt(filename) {
  const indexOfLastPeriod = filename.lastIndexOf(".");
  if (indexOfLastPeriod === -1) {
    return {
      name: filename,
      ext: ""
    };
  }
  const name = filename.substring(0, indexOfLastPeriod);
  const ext = filename.substring(indexOfLastPeriod + 1);
  return {
    name,
    ext
  };
}

// src/types/keep-data.ts
function objectIsKeepJson(fileContents) {
  return typeof fileContents.color !== "undefined" && typeof fileContents.isTrashed !== "undefined" && typeof fileContents.isPinned !== "undefined" && typeof fileContents.isArchived !== "undefined" && typeof fileContents.title !== "undefined" && typeof fileContents.userEditedTimestampUsec !== "undefined" && typeof fileContents.createdTimestampUsec !== "undefined";
}

// src/modals/start-import-modal/start-import-modal.ts
var import_obsidian5 = require("obsidian");

// src/modals/edit-settings-modal/edit-settings-modal.ts
var import_obsidian4 = require("obsidian");

// src/components/settings-groups/settings-groups.ts
var import_obsidian3 = require("obsidian");

// src/modals/confirmation-modal/confirmation-modal.ts
var import_obsidian2 = require("obsidian");
var ConfirmationModal = class extends import_obsidian2.Modal {
  constructor(options) {
    super(options.plugin.app);
    this.title = "Confirmation";
    this.message = "Are you sure?";
    this.cancelLabel = "Cancel";
    this.cancelAction = () => {
    };
    this.confirmLabel = "Yes";
    this.title = options.title || this.title;
    this.message = options.message || this.message;
    this.cancelLabel = options.cancelLabel || this.cancelLabel;
    this.confirmLabel = options.confirmLabel || this.confirmLabel;
    this.cancelAction = options.cancelAction || this.cancelAction;
    this.confirmAction = options.confirmAction;
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: this.message });
    new import_obsidian2.Setting(contentEl).addButton((cancelBtn) => {
      cancelBtn.setClass("gki_button");
      cancelBtn.setButtonText(this.cancelLabel);
      cancelBtn.onClick(() => {
        this.close();
        this.cancelAction();
      });
    }).addButton((confirmBtn) => {
      confirmBtn.setClass("gki_button");
      confirmBtn.setWarning();
      confirmBtn.setButtonText(this.confirmLabel);
      confirmBtn.onClick(() => {
        this.close();
        this.confirmAction();
      });
    });
  }
  onClose() {
    this.titleEl.empty();
    this.contentEl.empty();
  }
};

// src/components/settings-groups/settings-groups.ts
var BasicSettingsGroup = class {
  constructor(containerEl, plugin) {
    containerEl.createEl("h2", { text: "Basics" });
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Note import folder").addText((text) => {
      text.setValue(plugin.settings.folderNames.notes);
      text.inputEl.addEventListener("blur", async (e) => {
        const value = folderPathSanitize(text.getValue(), plugin.settings);
        plugin.settings.folderNames.notes = value;
        text.setValue(value);
        await plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Attachment import folder").addText((text) => {
      text.setValue(plugin.settings.folderNames.assets);
      text.inputEl.addEventListener("blur", async (e) => {
        const value = folderPathSanitize(text.getValue(), plugin.settings);
        plugin.settings.folderNames.assets = folderPathSanitize(value, plugin.settings);
        text.setValue(value);
        await plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Unsupported attachment import folder").addText((text) => {
      text.setValue(plugin.settings.folderNames.unsupportedAssets);
      text.inputEl.addEventListener("blur", async (e) => {
        const value = folderPathSanitize(text.getValue(), plugin.settings);
        plugin.settings.folderNames.unsupportedAssets = folderPathSanitize(value, plugin.settings);
        text.setValue(value);
        await plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Note creation date").setDesc("Should the imported note have a creation date set to the Google Keep note's creation date, or the date imported into Obsidian?").addDropdown((dropdown) => {
      dropdown.addOption("Google Keep creation date" /* googleKeep */, "Google Keep creation date" /* googleKeep */);
      dropdown.addOption("Obsidian import date" /* import */, "Obsidian import date" /* import */);
      dropdown.setValue(plugin.settings.createdDate);
      dropdown.onChange(async (value) => {
        plugin.settings.createdDate = value;
        await plugin.saveSettings();
      });
    });
  }
};
var InclusionSettingsGroup = class {
  constructor(containerEl, plugin) {
    containerEl.createEl("h2", { text: "Inclusions" });
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Import archived notes").addToggle((toggle) => {
      toggle.setValue(plugin.settings.importArchived);
      toggle.onChange(async (value) => {
        plugin.settings.importArchived = value;
        await plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Import trashed notes").addToggle((toggle) => {
      toggle.setValue(plugin.settings.importTrashed);
      toggle.onChange(async (value) => {
        plugin.settings.importTrashed = value;
        await plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Import unsupported files").setDesc("Importing unsupported files will place them in correct folders and notify you on import. But they won't show up in Obsidian until you convert them manually through another program.").addToggle((toggle) => {
      toggle.setValue(plugin.settings.importUnsupported);
      toggle.onChange(async (value) => {
        plugin.settings.importUnsupported = value;
        await plugin.saveSettings();
        importHtmlToggle.setDisabled(!value);
      });
    });
    let importHtmlToggle = new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Import html files").setDesc("HTML files may be unsupported by Obsidian and therefore won't appear, and they're also duplicates of supported JSON notes in a Google Keep export. So you probably don't want these regardless.").addToggle((toggle) => {
      toggle.setValue(plugin.settings.importHtml);
      toggle.onChange(async (value) => {
        plugin.settings.importHtml = value;
        await plugin.saveSettings();
      });
    }).setDisabled(!plugin.settings.importUnsupported);
  }
};
var TagSettingsGroup = class {
  constructor(containerEl, plugin) {
    containerEl.createEl("h2", { text: "Tags" });
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Add label tags").setDesc("Add a tag to represent each label present in the Google Keep note.").addToggle((toggle) => {
      toggle.setValue(plugin.settings.addLabelTags);
      toggle.onChange(async (value) => {
        plugin.settings.addLabelTags = value;
        await plugin.saveSettings();
        labelPrefixInput.setDisabled(!value);
      });
    });
    let labelPrefixInput = new import_obsidian3.Setting(containerEl).setClass("gki_setting").setClass("gki_setting-child").setDesc("Text to prepend to each label tag:").addText((text) => {
      text.setValue(plugin.settings.tagNames.labelPrepend);
      text.inputEl.addEventListener("blur", async (e) => {
        const value = text.getValue();
        plugin.settings.tagNames.labelPrepend = value;
        text.setValue(value);
        await plugin.saveSettings();
      });
    }).setDisabled(!plugin.settings.addColorTags);
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Add colour tags").setDesc("Add a tag representing the color of the note in Google Keep.").addToggle((toggle) => {
      toggle.setValue(plugin.settings.addColorTags);
      toggle.onChange(async (value) => {
        plugin.settings.addColorTags = value;
        await plugin.saveSettings();
        colorPrefixInput.setDisabled(!value);
      });
    });
    let colorPrefixInput = new import_obsidian3.Setting(containerEl).setClass("gki_setting").setClass("gki_setting-child").setDesc("Text to prepend to each colour tag:").addText((text) => {
      text.setValue(plugin.settings.tagNames.colorPrepend);
      text.inputEl.addEventListener("blur", async (e) => {
        const value = text.getValue();
        plugin.settings.tagNames.colorPrepend = value;
        text.setValue(value);
        await plugin.saveSettings();
      });
    }).setDisabled(!plugin.settings.addColorTags);
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Add pinned tags").setDesc("Add a tag if the note was pinned in Google Keep.").addToggle((toggle) => {
      toggle.setValue(plugin.settings.addPinnedTags);
      toggle.onChange(async (value) => {
        plugin.settings.addPinnedTags = value;
        await plugin.saveSettings();
        pinnedTagTextField.setDisabled(!value);
      });
    });
    let pinnedTagTextField = new import_obsidian3.Setting(containerEl).setClass("gki_setting").setClass("gki_setting-child").setDesc("Pinned tag:").addText((text) => {
      text.setValue(plugin.settings.tagNames.isPinned);
      text.inputEl.addEventListener("blur", async (e) => {
        const value = text.getValue();
        plugin.settings.tagNames.isPinned = value;
        text.setValue(value);
        await plugin.saveSettings();
      });
    }).setDisabled(!plugin.settings.addPinnedTags);
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Add attachment tags").setDesc("Add a tag if the note has an attachment.").addToggle((toggle) => {
      toggle.setValue(plugin.settings.addAttachmentTags);
      toggle.onChange(async (value) => {
        plugin.settings.addAttachmentTags = value;
        await plugin.saveSettings();
        attachmentTagTextField.setDisabled(!value);
      });
    });
    let attachmentTagTextField = new import_obsidian3.Setting(containerEl).setClass("gki_setting").setClass("gki_setting-child").setDesc("Attachment tag:").addText((text) => {
      text.setValue(plugin.settings.tagNames.hasAttachment);
      text.inputEl.addEventListener("blur", async (e) => {
        const value = text.getValue();
        plugin.settings.tagNames.hasAttachment = value;
        text.setValue(value);
        await plugin.saveSettings();
      });
    }).setDisabled(!plugin.settings.addAttachmentTags);
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Add archived tags").setDesc("Add a tag if the note was archived in Google Keep (If imported).").addToggle((toggle) => {
      toggle.setValue(plugin.settings.addArchivedTags);
      toggle.onChange(async (value) => {
        plugin.settings.addArchivedTags = value;
        await plugin.saveSettings();
        archivedTagTextField.setDisabled(!value);
      });
    });
    let archivedTagTextField = new import_obsidian3.Setting(containerEl).setClass("gki_setting").setClass("gki_setting-child").setDesc("Archived tag:").addText((text) => {
      text.setValue(plugin.settings.tagNames.isArchived);
      text.inputEl.addEventListener("blur", async (e) => {
        const value = text.getValue();
        plugin.settings.tagNames.isArchived = value;
        text.setValue(value);
        await plugin.saveSettings();
      });
    }).setDisabled(!plugin.settings.addArchivedTags);
    new import_obsidian3.Setting(containerEl).setClass("gki_setting").setName("Add trashed tags").setDesc("Add a tag if the note was trashed in Google Keep (If imported).").addToggle((toggle) => {
      toggle.setValue(plugin.settings.addTrashedTags);
      toggle.onChange(async (value) => {
        plugin.settings.addTrashedTags = value;
        await plugin.saveSettings();
        trashedTag.setDisabled(!value);
      });
    });
    let trashedTag = new import_obsidian3.Setting(containerEl).setClass("gki_setting").setClass("gki_setting-child").setDesc("Trashed tag:").addText((text) => {
      text.setValue(plugin.settings.tagNames.isTrashed);
      text.inputEl.addEventListener("blur", async (e) => {
        const value = text.getValue();
        plugin.settings.tagNames.isTrashed = value;
        text.setValue(value);
        await plugin.saveSettings();
      });
    }).setDisabled(!plugin.settings.addTrashedTags);
  }
};
var CharMappingGroup = class {
  constructor(containerEl, plugin, onComplete) {
    containerEl.createEl("h2", { text: "Character Mapping" });
    containerEl.createEl("p", { text: "Some characters don't work so well in file or folder names on certain operating systems. They will therefore be converted according to the following mapping settings." });
    containerEl.createEl("h3", { text: "Problem characters" });
    containerEl.createEl("p", { text: "While these won't break the imports, they will create issues with links from other files\u2014So are best avoided." });
    for (let k = 0; k < plugin.settings.problemChars.length; k++) {
      new import_obsidian3.Setting(containerEl).setClass("gki_setting-mapping").setName(plugin.settings.problemChars[k].char).addText((text) => {
        text.setValue(plugin.settings.problemChars[k].replacement);
        text.inputEl.addEventListener("blur", async (e) => {
          const value = text.getValue();
          plugin.settings.problemChars[k].replacement = value;
          text.setValue(value);
          await plugin.saveSettings();
        });
      });
    }
    containerEl.createEl("h3", { text: "Invalid characters" });
    containerEl.createEl("p", { text: "These don't work at all on certain operating systems and can break your import or cause errors when transferring files to other operating systems." });
    const invalidMapDropdown = new import_obsidian3.Setting(containerEl).setName("File and folder name compatibility").setDesc("You can choose to limit the invalid characters you map to suit the specific operating system you'd like your filenames to be compatible with. By default it's set to make your files compatible with all operating systems (And you should probably leave it like this).").addDropdown((dropdown) => {
      dropdown.addOption("all/windows" /* allOrWindows */, "All Operating Systems");
      dropdown.addOption("apple/android" /* appleOrAndroid */, "Apple and Android only");
      dropdown.addOption("linux" /* linux */, "Linux only");
      dropdown.setValue(plugin.settings.invalidCharFilter);
      dropdown.onChange(async (value) => {
        applyMappingPreset(value, plugin.settings);
        plugin.settings.invalidCharFilter = value;
        await plugin.saveSettings();
        onComplete();
      });
    });
    for (let k = 0; k < plugin.settings.invalidChars.length; k++) {
      new import_obsidian3.Setting(containerEl).setClass("gki_setting-mapping").setName(plugin.settings.invalidChars[k].char).addText((text) => {
        text.setValue(plugin.settings.invalidChars[k].replacement);
        text.inputEl.addEventListener("blur", async (e) => {
          const value = text.getValue();
          plugin.settings.invalidChars[k].replacement = value;
          text.setValue(value);
          await plugin.saveSettings();
        });
      });
    }
  }
};
function addResetButton(settingEl, plugin, onComplete) {
  return settingEl.addButton((button) => {
    button.setButtonText("Reset settings");
    button.setClass("gki_button");
    button.onClick(() => {
      new ConfirmationModal({
        plugin,
        title: "Please confirm",
        message: "Reset to default settings for Google Keep Import?",
        confirmLabel: "Reset settings",
        confirmAction: async () => {
          await plugin.resetSettings();
          onComplete();
        }
      }).open();
    });
  });
}

// src/modals/edit-settings-modal/edit-settings-modal.ts
var EditSettingsModal = class extends import_obsidian4.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.duplicateNotes = 0;
    this.fileBacklog = [];
    this.plugin = plugin;
  }
  showModal() {
    return new Promise((resolve, reject) => {
      this.open();
      this.resolveModal = resolve;
      this.rejectModal = reject;
    });
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h1", { text: "Google Keep Import Settings" });
    contentEl.createEl("p", { text: "All settings will save immediately. Close this modal to return to your import." });
    contentEl.createEl("hr");
    new BasicSettingsGroup(contentEl, this.plugin);
    contentEl.createEl("hr");
    new InclusionSettingsGroup(contentEl, this.plugin);
    contentEl.createEl("hr");
    new TagSettingsGroup(contentEl, this.plugin);
    contentEl.createEl("hr");
    new CharMappingGroup(contentEl, this.plugin, () => this.onOpen());
    contentEl.createEl("hr");
    const modalActions = new import_obsidian4.Setting(contentEl);
    new SupportButtonSet(modalActions);
    addResetButton(modalActions, this.plugin, () => this.onOpen());
    modalActions.addButton((button) => {
      button.setButtonText("Close");
      button.setClass("gki_button");
      button.setCta();
      button.onClick(() => {
        this.close();
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/modals/start-import-modal/start-import-modal.ts
var StartImportModal = class extends import_obsidian5.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.duplicateNotes = 0;
    this.fileBacklog = [];
    this.plugin = plugin;
  }
  showModal() {
    return new Promise((resolve, reject) => {
      this.open();
      this.resolveModal = resolve;
      this.rejectModal = reject;
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Import Google Keep Files" });
    const firstParaEl = contentEl.createEl("p", {
      text: "To export your files from Google Keep, open ",
      cls: "gki_info-bubble"
    });
    firstParaEl.createEl("a", {
      text: "Google Takeout",
      href: "https://takeout.google.com/"
    });
    firstParaEl.appendText(" and select only Google Keep files. Once you have the exported zip, unzip it and drag all the files in below.");
    const dropFrame = contentEl.createEl("div", { cls: "gki_drop-frame" });
    dropFrame.createEl("div", { cls: "gki_highlight" });
    const dropFrameText = dropFrame.createEl("p", { text: "Drag all files here or " });
    dropFrameText.createEl("label", {
      text: "browse local files",
      attr: {
        "class": "gki_file-input_label",
        "for": "gki_file-input"
      }
    });
    this.uploadInput = dropFrameText.createEl("input", {
      type: "file",
      attr: {
        "multiple": true,
        "id": "gki_file-input"
      }
    });
    this.importSummary = new ImportSummary(dropFrame);
    this.importSummary.hide();
    this.notesSpan = this.importSummary.addItem("notes");
    this.attachmentsSpan = this.importSummary.addItem("other");
    this.modalActions = new import_obsidian5.Setting(contentEl);
    new SupportButtonSet(this.modalActions);
    this.modalActions.addButton((btn) => {
      btn.setClass("gki_button");
      btn.setButtonText("Edit settings");
      btn.onClick(async (e) => {
        const modal = new EditSettingsModal(this.plugin);
        modal.showModal();
      });
    });
    this.startBtn = this.modalActions.addButton((btn) => {
      btn.setClass("gki_button");
      btn.setCta();
      btn.setButtonText("Start Import");
      btn.setDisabled(true);
      btn.onClick((e) => {
        this.resolveModal(this.fileBacklog);
        this.close();
      });
    });
    this.uploadInput.addEventListener("change", () => {
      this.addToFilesBacklog(Object.values(this.uploadInput.files));
    });
    dropFrame.addEventListener("dragenter", (e) => {
      dropFrame.addClass("gki_drag-over-active");
    });
    dropFrame.addEventListener("dragleave", (e) => {
      dropFrame.removeClass("gki_drag-over-active");
    });
    dropFrame.addEventListener("dragover", (e) => {
      e.preventDefault();
    });
    dropFrame.addEventListener("drop", (e) => {
      e.preventDefault();
      dropFrame.removeClass("gki_drag-over-active");
      if (e.dataTransfer === null)
        return;
      const files = [];
      if (e.dataTransfer.items) {
        const items = [...e.dataTransfer.items];
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item.kind === "file") {
            const file = item.getAsFile();
            if (file)
              files.push(file);
          }
        }
        ;
      } else {
        files.push(...e.dataTransfer.files);
      }
      this.addToFilesBacklog(files);
    });
  }
  addToFilesBacklog(files) {
    let newFiles = 0;
    let duplicateFiles = 0;
    files.forEach((file) => {
      if (this.backlogContains(file)) {
        duplicateFiles++;
      } else {
        this.fileBacklog.push(file);
        newFiles++;
      }
    });
    if (duplicateFiles > 0) {
      new import_obsidian5.Notice(`${duplicateFiles} ${singleOrPlural(duplicateFiles, "file")} ignored because ${singleOrPlural(duplicateFiles, "it's", "they're")} already in the import list.`, 9e3);
    }
    new import_obsidian5.Notice(`${newFiles} new ${singleOrPlural(newFiles, "file")} queued for import.`, 1e4);
    this.uploadInput.files = null;
    const breakdown = this.getBacklogBreakdown();
    this.notesSpan.setText(`${breakdown.notes}`);
    this.attachmentsSpan.setText(`${breakdown.assets}`);
    this.importSummary.show();
    this.startBtn.setDisabled(false);
  }
  backlogContains(file) {
    for (let i = 0; i < this.fileBacklog.length; i++) {
      if (file.path) {
        if (file.path == this.fileBacklog[i].path)
          return true;
      }
    }
    return false;
  }
  getBacklogBreakdown() {
    let notes = 0;
    let assets = 0;
    for (let i = 0; i < this.fileBacklog.length; i++) {
      const file = this.fileBacklog[i];
      if (fileIsJson(file)) {
        notes++;
      } else {
        assets++;
      }
    }
    return {
      notes,
      assets
    };
  }
  onClose() {
    this.titleEl.empty();
    this.contentEl.empty();
  }
};

// src/logic/import-logic.ts
async function runImportSequence(plugin) {
  const modal = new StartImportModal(plugin);
  let fileBacklog;
  try {
    fileBacklog = await modal.showModal();
  } catch (e) {
    return;
  }
  const fileImporter = new FileImporter(plugin);
  fileImporter.import(fileBacklog);
  const progressModal = await new ImportProgressModal(plugin, fileImporter);
  try {
    await progressModal.showModal();
  } catch (message) {
    fileImporter.stop();
    new import_obsidian6.Notice(message, 9e3);
    return;
  }
}
async function createNewEmptyMdFile(vault, pathAndName, options, version = 1) {
  let fileRef;
  let pathAndVersionedName;
  if (version == 1) {
    pathAndVersionedName = pathAndName;
  } else {
    pathAndVersionedName = `${pathAndName} (${version})`;
  }
  if (await vault.adapter.exists(`${pathAndVersionedName}.md`)) {
    fileRef = await createNewEmptyMdFile(vault, pathAndName, options, version + 1);
  } else {
    fileRef = await vault.create(`${pathAndVersionedName}.md`, "", options);
  }
  return fileRef;
}
async function getOrCreateFolder(folderPath, vault) {
  let folder = null;
  let folderExists = await vault.adapter.exists(folderPath);
  if (!folderExists) {
    await vault.createFolder(folderPath);
  }
  return vault.getAbstractFileByPath(folderPath);
}
var FileImporter = class {
  constructor(plugin) {
    this.totalImports = 0;
    this.successCount = 0;
    this.failCount = 0;
    this.skipCount = 0;
    this.activeImport = false;
    this.outputLog = [];
    this.outputLogIter = 0;
    this.plugin = plugin;
  }
  async import(files) {
    const vault = this.plugin.app.vault;
    const settings = this.plugin.settings;
    this.activeImport = true;
    this.totalImports = files.length;
    this.successCount = 0;
    this.failCount = 0;
    this.skipCount = 0;
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      let result;
      if (!this.activeImport)
        return;
      if (fileIsJson(file)) {
        result = await importJson(vault, settings.folderNames.notes, file, settings);
      } else if (fileIsMarkdown(file)) {
        result = await importBinaryFile(vault, settings.folderNames.notes, file);
      } else if (fileIsBinaryAndSupportedByObsidian(file)) {
        result = await importBinaryFile(vault, settings.folderNames.assets, file);
      } else if (fileIsHtml(file) && settings.importUnsupported && settings.importHtml) {
        result = await importBinaryFile(vault, settings.folderNames.unsupportedAssets, file);
        if (result.logStatus === 3 /* Success */) {
          result.logStatus = 2 /* Warning */;
          result.details = `<p>This file has been imported to '${settings.folderNames.unsupportedAssets}' because you've turned it on in the settings. However, HTML files may not be supported by Obsidian and thus may not be visible.</p><p>Also note that Google Takeout exports only include HTML files that are redundant to the included JSON note files. So if your importing a Takeout export you should leave HTML files turned off.</p>`;
        }
      } else if (fileIsHtml(file) && (!settings.importUnsupported || !settings.importHtml)) {
        result = {
          keepFilename: file.name,
          logStatus: 0 /* Note */,
          details: `<p>HTML files in Google Takeout exports are redundant backups and this file has therefore been skipped. The note it relates too will have an equivalent JSON file that should have imported.</p><p>You can force HTML files to import in the settings but they may be unsupported by Obsidian.</p>`
        };
      } else if (!fileIsHtml(file) && settings.importUnsupported) {
        result = await importBinaryFile(vault, settings.folderNames.unsupportedAssets, file);
        if (result.logStatus === 3 /* Success */) {
          result.logStatus = 2 /* Warning */;
          result.details = `This file type isn't a Google Keep JSON and isn't recognised by this plugin as Obsidian supported. It has been imported into '${settings.folderNames.unsupportedAssets}' as per your settings, but will only be visible in Obsidian if it's supported as is, if not, open that folder outside of Obsidian to convert or deleted the files. Any links to those files in notes will also need to be updated.`;
        }
      } else {
        result = {
          keepFilename: file.name,
          logStatus: 0 /* Note */,
          details: `This file type isn't supported by Obsidian and has been skipped. You can change this behaviour in the settings.`
        };
      }
      this.updateOutputLog(result);
    }
  }
  updateOutputLog(result) {
    if (result.logStatus === 2 /* Warning */) {
      this.successCount++;
      this.outputLog.push({
        status: "Warning",
        title: `${result.keepFilename}`,
        desc: `${result.details} ${result.obsidianFilepath || ""}`
      });
    } else if (result.logStatus === 1 /* Error */) {
      this.failCount++;
      this.outputLog.push({
        status: "Error",
        title: `${result.keepFilename}`,
        desc: `${result.details} ${result.obsidianFilepath ? `<p><em>Intended name:</em> ${result.obsidianFilepath}` : ""} <p><em>${result.error || ""}</em></p>`
      });
    } else if (result.logStatus === 0 /* Note */) {
      this.skipCount++;
      this.outputLog.push({
        status: "Note",
        title: `${result.keepFilename}`,
        desc: `${result.details} <p><em>${result.error || ""}</em></p>`
      });
    } else {
      this.successCount++;
    }
  }
  getTotalImports() {
    return this.totalImports;
  }
  getLatestProgress() {
    let newLogEntries = [];
    if (this.outputLogIter < this.totalImports) {
      newLogEntries = this.outputLog.slice(this.outputLogIter);
      this.outputLogIter += newLogEntries.length;
    }
    return {
      successCount: this.successCount,
      failCount: this.failCount,
      skipCount: this.skipCount,
      newLogEntries
    };
  }
  stop() {
    this.activeImport = false;
  }
};
function fileIsJson(file) {
  return getFileExtension(file.name) === ".json" || file.type === "application/json";
}
function fileIsMarkdown(file) {
  return getFileExtension(file.name) === ".md" || file.type === "text/markdown" || file.type === "text/x-markdown";
}
function fileIsBinaryAndSupportedByObsidian(file) {
  const isImageFile = file.type === "image/png" || file.type === "image/webp" || file.type === "image/jpeg" || file.type === "image/gif" || file.type === "image/bmp" || file.type === "image/svg+xml";
  const isAudioFile = file.type === "audio/mpeg" || file.type === "audio/m4a" || file.type === "audio/webm" || file.type === "audio/wav" || file.type === "audio/ogg" || file.type === "audio/3gpp" || file.type === "audio/x-flac";
  const isVideoFile = file.type === "video/mp4" || file.type === "video/webm" || file.type === "video/ogg" || file.type === "video/3gpp" || file.type === "video/quicktime" || file.type === "video/x-matroska";
  const isOtherFile = file.type === "application/pdf";
  return isImageFile || isAudioFile || isVideoFile || isOtherFile;
}
function fileIsHtml(file) {
  const ext = getFileExtension(file.name);
  return ext === "html" || ext === "htm" || file.type === "text/html";
}
async function importJson(vault, folderPath, file, settings) {
  let folder;
  const result = {
    keepFilename: file.name,
    logStatus: 3 /* Success */
  };
  return new Promise(async (resolve, reject) => {
    try {
      folder = await getOrCreateFolder(folderPath, vault);
    } catch (e) {
      console.log(e);
      result.logStatus = 1 /* Error */;
      result.details = `<p>Please check the intended name doesn't include any characters not allowed by your operating system. This can happen if you've modified the character mapping options in this plugin's settings so that they don't match your operating system.</p>`;
      return resolve(result);
    }
    var reader = new FileReader();
    reader.readAsText(file, "UTF-8");
    reader.onerror = reject;
    reader.onload = async (readerEvent) => {
      if (!readerEvent || !readerEvent.target) {
        result.logStatus = 1 /* Error */;
        result.details = "Something went wrong reading the file.";
        return resolve(result);
      }
      let content;
      try {
        content = JSON.parse(readerEvent.target.result);
      } catch (e) {
        console.log(e);
        result.logStatus = 1 /* Error */;
        result.details = `<p>JSON file appears to be malformed and can't be imported. You can open this file and either attempt to correct and reimport it, or to copy it's contents manually.</p>
				<p><a href="https://www.toptal.com/developers/json-formatter">Toptal JSON Formatter</a> can help to find errors and format JSON data for easier manual copying. Open the file in a text editor (or drag it into a browser tab), to copy the contents into the formatter.</p>`;
        return resolve(result);
      }
      if (!objectIsKeepJson(content)) {
        result.logStatus = 1 /* Error */;
        result.details = `JSON file doesn't match the expected Google Keep format and therefore can't be imported.`;
        return resolve(result);
      }
      if (content.isArchived && !settings.importArchived) {
        result.logStatus = 0 /* Note */;
        result.ignoredReason = 1 /* Archived */;
        return resolve(result);
      }
      if (content.isTrashed && !settings.importTrashed) {
        result.logStatus = 0 /* Note */;
        result.ignoredReason = 0 /* Trashed */;
        return resolve(result);
      }
      let path = `${folder.path}/${filenameSanitize(content.title || getNameAndExt(file.name).name, settings)}`;
      result.obsidianFilepath = path;
      let fileRef;
      try {
        fileRef = await createNewEmptyMdFile(vault, path, {});
      } catch (error) {
        result.logStatus = 1 /* Error */;
        result.error = error;
        result.details = `<p>Please check the intended name doesn't include any characters not allowed by your operating system. This can happen if you've modified the character mapping options in this plugin's settings so that they don't match your operating system.</p>`;
        return resolve(result);
      }
      try {
        settings.addColorTags ? await vault.append(fileRef, `${settings.tagNames.colorPrepend}${content.color} `) : null;
        content.isPinned && settings.addPinnedTags ? await vault.append(fileRef, `${settings.tagNames.isPinned} `) : null;
        content.attachments && settings.addAttachmentTags ? await vault.append(fileRef, `${settings.tagNames.hasAttachment} `) : null;
        content.isArchived && settings.addArchivedTags ? await vault.append(fileRef, `${settings.tagNames.isArchived} `) : null;
        content.isTrashed && settings.addTrashedTags ? await vault.append(fileRef, `${settings.tagNames.isTrashed} `) : null;
      } catch (error) {
        result.logStatus = 1 /* Error */;
        result.error = error;
        result.details = "Error adding tags to the new file.";
        return resolve(result);
      }
      try {
        appendKeepLabels(fileRef, content, settings, vault);
      } catch (error) {
        result.logStatus = 1 /* Error */;
        result.error = error;
        result.details = "Error adding labels to the new file.";
        return resolve(result);
      }
      try {
        if (content.textContent) {
          await vault.append(fileRef, `

`);
          await vault.append(fileRef, `${content.textContent}
`);
        }
      } catch (error) {
        result.logStatus = 1 /* Error */;
        result.error = error;
        result.details = "Error adding paragraph content to the new file.";
        return resolve(result);
      }
      try {
        if (content.listContent) {
          await vault.append(fileRef, `

`);
          for (let i = 0; i < content.listContent.length; i++) {
            const listItem = content.listContent[i];
            if (!listItem.text)
              continue;
            let listItemContent = `- [${listItem.isChecked ? "X" : " "}] ${listItem.text}
`;
            await vault.append(fileRef, listItemContent);
          }
        }
      } catch (error) {
        result.logStatus = 1 /* Error */;
        result.error = error;
        result.details = "Error adding list content to the new file.";
        return resolve(result);
      }
      if (content.attachments) {
        for (let i = 0; i < content.attachments.length; i++) {
          const attachment = content.attachments[i];
          try {
            await vault.append(fileRef, `

![[${attachment.filePath}]]`);
          } catch (error) {
            result.logStatus = 1 /* Error */;
            result.error = error;
            result.details = `Error embedding attachment '${attachment.filePath}' to the new file.`;
            return resolve(result);
          }
        }
      }
      if (settings.createdDate === "Google Keep creation date" /* googleKeep */) {
        const options = {
          ctime: content.createdTimestampUsec / 1e3,
          mtime: content.userEditedTimestampUsec / 1e3
        };
        await vault.append(fileRef, "", options);
      }
      return resolve(result);
    };
  });
}
async function appendKeepLabels(fileRef, content, settings, vault) {
  if (!settings.addLabelTags)
    return;
  if (!content.labels)
    return;
  let labels = "";
  for (let i = 0; i < content.labels.length; i++) {
    const name = content.labels[i].name.split(" ").join("-");
    if (i > 0)
      labels += " ";
    labels += settings.tagNames.labelPrepend + name;
  }
  await vault.append(fileRef, labels);
}
async function importBinaryFile(vault, folderPath, file) {
  let fileRef;
  let folder;
  let path;
  const result = {
    keepFilename: file.name,
    logStatus: 3 /* Success */
  };
  try {
    folder = await getOrCreateFolder(folderPath, vault);
    path = `${folder.path}/${file.name}`;
  } catch (e) {
    console.log(e);
    result.logStatus = 1 /* Error */;
    result.details = `<p>Error creating folder '${folderPath}'.</p>
		<p>Please check it doesn't include any characters not allowed by your operating system. This can happen if you've modified the character mapping options in the settings so that they don't match your operating system.</p>`;
    return Promise.resolve(result);
  }
  try {
    fileRef = await vault.createBinary(path, await file.arrayBuffer());
  } catch (error) {
    result.logStatus = 1 /* Error */;
    result.error = error;
    result.details = `Error creating file at '${path}'.`;
    return Promise.resolve(result);
  }
  return Promise.resolve(result);
}
function applyMappingPreset(presetType, settings) {
  if (presetType === "apple/android" /* appleOrAndroid */) {
    settings.invalidChars = JSON.parse(JSON.stringify(invalidChars_appleOrAndroidPreset));
  } else if (presetType === "linux" /* linux */) {
    settings.invalidChars = JSON.parse(JSON.stringify(invalidChars_linuxPreset));
  } else {
    settings.invalidChars = JSON.parse(JSON.stringify(invalidChars_allOrWindowsPreset));
  }
}

// src/tabs/settings-tab/settings-tab.ts
var import_obsidian7 = require("obsidian");
var MySettingsTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Google Keep Import Settings" });
    containerEl.createEl("p", { text: "All settings will save immediately. Close this modal to return to your import." });
    containerEl.createEl("hr");
    new BasicSettingsGroup(containerEl, this.plugin);
    containerEl.createEl("hr");
    new InclusionSettingsGroup(containerEl, this.plugin);
    containerEl.createEl("hr");
    new TagSettingsGroup(containerEl, this.plugin);
    containerEl.createEl("hr");
    new CharMappingGroup(containerEl, this.plugin, () => this.display());
    containerEl.createEl("hr");
    const modalActions = new import_obsidian7.Setting(containerEl);
    new SupportButtonSet(modalActions);
    addResetButton(modalActions, this.plugin, () => this.display());
  }
};

// src/assets/mastodon.ts
var mastodon_default = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" stroke="currentColor" stroke-width="6" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
        <path d="M47.4883 94.9079C42.5177 94.9079 37.3373 94.211 32.1064 92.8256C15.5071 88.426 12.8622 71.0794 12.4676 54.6899C12.3837 51.1551 12.4005 47.7463 12.4089 44.7404C12.4089 43.6573 12.4172 42.6162 12.4172 41.6338C12.4256 23.8086 24.1552 18.3595 24.6506 18.1328C31.292 15.0849 42.1231 14.3712 50.0323 14.3041H50.2842C58.2103 14.3629 69.0414 15.0849 75.708 18.1495C76.1866 18.3595 87.9161 23.817 87.9161 41.6338C87.9161 42.1124 88.0337 48.1745 86.3712 56.7302C85.0782 63.3968 75.6912 69.8199 65.4478 71.0458C61.0146 71.5747 57.0012 72.0114 52.7443 72.0114C51.8375 72.0114 50.9307 71.9946 50.0575 71.9526C45.0702 71.7259 35.3138 71.0794 32.4758 70.5672C33.5757 75.1431 34.3398 82.8089 50.3598 82.2212C50.7208 82.2044 51.0819 82.238 51.4429 82.238C57.3371 82.238 62.4588 80.6511 62.5175 80.6343C64.096 80.1389 65.7081 81.2724 65.7837 82.918L66.0691 89.1396C66.1111 90.1052 65.599 91.0204 64.7425 91.4738C64.5242 91.5914 59.3354 94.3285 50.3094 94.8323C49.3774 94.8827 48.4287 94.9079 47.4799 94.9079H47.4883Z"/>
    </svg>
`;

// src/main.ts
var invalidChars_allOrWindowsPreset = [
  { char: "*", replacement: "+" },
  { char: '"', replacement: "'" },
  { char: "\\", replacement: "-" },
  { char: "/", replacement: "-" },
  { char: "<", replacement: "(" },
  { char: ">", replacement: ")" },
  { char: ":", replacement: "_" },
  { char: "|", replacement: "_" },
  { char: "?", replacement: "" }
];
var invalidChars_appleOrAndroidPreset = [
  { char: "*", replacement: "+" },
  { char: "\\", replacement: "-" },
  { char: "/", replacement: "-" },
  { char: ":", replacement: "_" },
  { char: "|", replacement: "_" },
  { char: "?", replacement: "" }
];
var invalidChars_linuxPreset = [
  { char: "/", replacement: "-" }
];
var DEFAULT_SETTINGS = {
  folderNames: {
    notes: "Keep Imports",
    assets: "Keep Imports/Assets",
    unsupportedAssets: "Keep Imports/Unsupported Assets"
  },
  createdDate: "Google Keep creation date" /* googleKeep */,
  importArchived: true,
  importTrashed: false,
  importUnsupported: false,
  importHtml: false,
  addColorTags: true,
  addLabelTags: true,
  addPinnedTags: true,
  addAttachmentTags: true,
  addArchivedTags: true,
  addTrashedTags: true,
  tagNames: {
    colorPrepend: "#Keep/Colour/",
    labelPrepend: "#Keep/Label/",
    isPinned: "#Keep/Pinned",
    hasAttachment: "#Keep/Attachments",
    isArchived: "#Keep/Archived",
    isTrashed: "#Keep/Trashed"
  },
  problemChars: [
    {
      char: "#",
      replacement: ""
    },
    {
      char: "^",
      replacement: ""
    },
    {
      char: "[",
      replacement: "("
    },
    {
      char: "]",
      replacement: ")"
    },
    {
      char: "|",
      replacement: "_"
    }
  ],
  invalidChars: JSON.parse(JSON.stringify(invalidChars_allOrWindowsPreset)),
  invalidCharFilter: "all/windows" /* allOrWindows */
};
var GoogleKeepImportPlugin2 = class extends import_obsidian8.Plugin {
  async onload() {
    await this.loadSettings();
    (0, import_obsidian8.addIcon)("mastodon", mastodon_default);
    this.addCommand({
      id: "import-files",
      name: "Import files",
      callback: () => runImportSequence(this)
    });
    this.addSettingTab(new MySettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async resetSettings() {
    this.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
    this.saveSettings();
    new import_obsidian8.Notice("Google Keep Import settings reset");
  }
};


/* nosourcemap */